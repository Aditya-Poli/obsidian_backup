
Given an array of integersÂ `nums`Â containingÂ `n + 1`Â integers where each integer is in the rangeÂ `[1, n]`Â inclusive.

There is onlyÂ **one repeated number**Â inÂ `nums`, returnÂ _thisÂ repeatedÂ number_.

You must solve the problemÂ **without**Â modifying the arrayÂ `nums`Â and uses only constant extra space.

**Example 1:**

**Input:** nums = [1,3,4,2,2]
**Output:** 2

**Example 2:**

**Input:** nums = [3,1,3,4,2]
**Output:** 3

**Constraints:**

- `1 <= n <= 10^5`
- `nums.length == n + 1`
- `1 <= nums[i] <= n`
- All the integers inÂ `nums`Â appear onlyÂ **once**Â except forÂ **precisely one integer**Â which appearsÂ **two or more**Â times.

**Follow up:**

- How can we prove that at least one duplicate number must exist inÂ `nums`?
- Can you solve the problem in linear runtime complexity?


## Solution
9 Approaches: Count, Hash, In-place Marked, Sort, Binary Search, Bit Mask, Fast Slow Pointers

`Hash Table`  `Two Pointers`  `Binary Search`   `Bit Manipulation`


[Leetcode](https://leetcode.com/)Â [287. Find the Duplicate Number](https://leetcode.com/problems/coin-change/).

Here areÂ **9**Â approaches to solve this problem in Java, which is Brute Force, Count, Hash, In-place Marked, Sorting, Index Sort, Binary Search, Bit Manipulation, Fast Slow Pointers.

Inspired by @[user2670f](https://leetcode.com/u/user2670f)Â and his solutionÂ [[C++] 7 Different solutions to this problem (with relaxed constraints)](https://leetcode.com/problems/find-the-duplicate-number/discuss/1894339/C%2B%2B-8-Different-solutions-to-this-problem-or-Do-you-have-another-one)Â , I addedÂ **3**Â more approaches.

### Brute Force (2 Loops)

SinceÂ `solve the problem without modifying the array nums and uses only constant extra space`, we can use Brute Force to solve it.

It's easy to useÂ **2 loops**Â to do it, but the time complexity isÂ O(n2)O(n^2)O(n2), so it wouldn't accepted as timeout.

```java
    // 2 Loops
    public static int findDuplicate_2loops(int[] nums) {
        int len = nums.length;
        for (int i = 0; i < len; i++) {
            for (int j = i + 1; j < len; j++) {
                if (nums[i] == nums[j]) {
                    return nums[i];
                }
            }
        }

        return len;
    }
```

#### Analysis

- **Time Complexity**:Â O(n<sup>2</sup>)
- **Space Complexity**:Â O(1)

### Count

Count the frequency of the num in the array.

With extraÂ O(n)Â space, without modifying the input.

```java
    public static int findDuplicate(int[] nums) {
        int len = nums.length;
        int[] cnt = new int[len + 1];
        for (int i = 0; i < len; i++) {
            cnt[nums[i]]++;
            if (cnt[nums[i]] > 1) {
                return nums[i];
            }
        }

        return len;
    }
```

#### Analysis

- **Time Complexity**:Â O(n)
- **Space Complexity**:Â O(n)

### Hash

Using aÂ HashSet\texttt{HashSet}HashSetÂ to record the occurrence of each number.

With extraÂ O(n)Â space, without modifying the input.

```java
    public static int findDuplicate_set(int[] nums) {
        Set<Integer> set = new HashSet<>();
        int len = nums.length;
        for (int i = 0; i < len; i++) {
            if (!set.add(nums[i])) {
                return nums[i];
            }
        }

        return len;
    }
```

#### Analysis

- **Time Complexity**:Â O(n)
- **Space Complexity**:Â O(n)

### Marking visited value within the array

Since all values of the array are betweenÂ [1â€¦n][1 \dots n][1â€¦n]Â and the array size isÂ n+1n+1n+1, while scanning the array from left to right, we set theÂ nums[n]Â to its negative value.

With extraÂ O(1)Â space, with modifying the input.

```java
    // Visited
    public static int findDuplicate_mark(int[] nums) {
        int len = nums.length;
        for (int num : nums) {
            int idx = Math.abs(num);
            if (nums[idx] < 0) {
                return idx;
            }
            nums[idx] = -nums[idx];
        }

        return len;
    }
```

#### Analysis

- **Time Complexity**:Â O(n)
- **Space Complexity**:Â O(1)

### Sort

Sorting the array first, then use a loop fromÂ 1Â toÂ n.

With extraÂ O(nlogn)Â space, modifying the input.

```java
    public static int findDuplicate_sort(int[] nums) {
        Arrays.sort(nums);
        int len = nums.length;
        for (int i = 1; i < len; i++) {
            if (nums[i] == nums[i - 1]) {
                return nums[i];
            }
        }

        return len;
    }
```

#### Analysis

- **Time Complexity**:Â O(nlogn)
- **Space Complexity**:Â O(logn)

### Index Sort

If the array is sorted, the value of each array element is its index valueÂ index+1, then we can do this:

1. IfÂ *nums[i] == i + 1*, it means that the order has been sorted, then skip,Â i++i++i++;
2. IfÂ *nums[i] == nums[nums[i]âˆ’1]*, it means that there is already a value at the correct index, then this value is a duplicated element;
3. If none of the above is satisfied, exchange the values ofÂ *nums[i]* and *nums[nums[i]-1]*.

With extraÂ O(logn)Â space, with modifying the input.

```java
    // Index Sort
    // n + 1 numbers in n.
    public static int findDuplicate_index_sort(int[] nums) {
        int len = nums.length;
        for (int i = 0; i < len; ) {
            int n = nums[i];
            if (n == i + 1) {
                i++;
            } else if (n == nums[n - 1]) {
                return n;
            } else {
                nums[i] = nums[n - 1];
                nums[n - 1] = n;
            }
        }

        return 0;
    }
```

#### Analysis

- **Time Complexity**:Â O(n)
- **Space Complexity**:Â O(1)

### Binary Search

Note that the key is to find an integer in the array [1,2,â€¦,n]Â instead of finding an integer in theÂ **input array**.

We can use the binary search algorithm, each round we guess one number, then scan the input array, narrow the search range, and finally ge t the answer.

According to theÂ **Pigeonhole Principle**,Â n+1n + 1n+1Â integers, placed in an array of lengthÂ nnn, at leastÂ 111Â integer will be repeated.

So guess a number first(the numberÂ midmidmidÂ in the valid range [left,right]), count the elements of the array which is less than or equal toÂ midmidmidÂ in the array.

1. IfÂ cntcntcntÂ is strictly greater thanÂ midmidmid. According to the Pigeonhole Principle, repeated elements are in the intervalÂ  [left,mid];
2. Otherwise, the repeated element is in the interval [mid+1,right].

With extraÂ O(1)Â space, without modifying the input.

```java
    public static int findDuplicate_bs(int[] nums) {
        int len = nums.length;
        int low = 1;
        int high = len - 1;
        while (low < high) {
            int mid = low + (high - low) / 2;
            int cnt = 0;
            for (int i = 0; i < len; i++) {
                if (nums[i] <= mid) {
                    cnt++;
                }
            }

            if (cnt <= mid) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }

        return low;
    }
```

#### Analysis

- **Time Complexity**:Â O(nlogn)
- **Space Complexity**:Â O(1)

### Bit

This method is convert all the numbers toÂ **binary**Â numbers. If we can getÂ **each digit**Â of the repeated number in binary, we can rebuild the repeated number.

Count all the bits of [1,n]Â and array numbers asÂ 1Â respectively, and then restore them bit by bit to get this repeated number.

For example, theÂ ith digit, note that in theÂ *nums*Â array, the sum of all the elements whose ith digit isÂ 1Â isÂ  *x*Â as convert the number to binary.

As the range [1,n], we can also count the sum of the number whoseÂ iiith digit isÂ 111, we denoted itÂ y.

We can easily get thatÂ x>y.

The following table lists whether each bit in the binary of each number isÂ 111Â orÂ 000Â and what theÂ xxxÂ andÂ yÂ of the corresponding bit are:

||1|3|4|2|2|x|y|
|---|---|---|---|---|---|---|---|
|Bit 0|1|1|0|0|0|2|2|
|Bit 1|1|0|1|1|1|3|2|
|Bit 2|0|0|1|0|0|1|1|

From the table, we found that only theÂ 1th bitÂ x>y, so after bitwise restorationÂ target=(010)<sub>2</sub>=(2)<sub>10</sub>, which is the answer.

The proof of correctness is actually similar to methodÂ 1. We can consider the change of the numberÂ xÂ of theÂ i-th in different example arrays.

- IfÂ targetÂ appears twice in the test case array, the rest of the numbers appear once, and theÂ ith bit ofÂ targetÂ isÂ 1, then theÂ numsÂ array x, is exactly one greater than y. If bitÂ iÂ of target isÂ 0, then both are equal.
    
- IfÂ targetÂ appears three or more times in the array of test cases, then there must be some numbers that are not in theÂ numsÂ array. At this time, it is equivalent to replacing these withÂ target, we consider the impact onÂ xxxÂ when replacing:
    
    - If theÂ i-th bit of the number to be replaced isÂ 1, and theÂ i-th bit ofÂ targetÂ isÂ 1:Â xÂ remains unchanged,Â x>y.
        
    - If theÂ i-th bit of the number being replaced isÂ 0, and theÂ i-th bit ofÂ targetÂ isÂ 1: x plus one,Â x>y.
        
    - If the i-th bit of the number to be replaced isÂ 1, and theÂ i-th bit ofÂ targetÂ isÂ 0:Â xÂ minus one,Â xâ‰¤y.
        
    - If theÂ i-th bit of the number to be replaced isÂ 000, and theÂ i-th bit ofÂ targetÂ isÂ 000: x remains unchanged, satisfyingÂ xâ‰¤y.
        

Therefore, if the ith bit ofÂ targetÂ isÂ 1, then after each replacement, onlyÂ xÂ will be unchanged or increased. If it isÂ 0, onlyÂ xÂ will be unchanged or decreased.

WhenÂ x>y, the ith bit ofÂ targetÂ isÂ 1, otherwise it isÂ 0. We only need to restore this repeated number bitwise.

With extraÂ O(nlogn)Â space, without modifying the input.

```java
    public static int findDuplicate_bit(int[] nums) {
        int n = nums.length;
        int ans = 0;
        int bit_max = 31;
        while (((n - 1) >> bit_max) == 0) {
            bit_max -= 1;
        }

        for (int bit = 0; bit <= bit_max; ++bit) {
            int x = 0, y = 0;
            for (int i = 0; i < n; ++i) {
                if ((nums[i] & (1 << bit)) != 0) {
                    x += 1;
                }
                if (i >= 1 && ((i & (1 << bit)) != 0)) {
                    y += 1;
                }
            }
            if (x > y) {
                ans |= 1 << bit;
            }
        }

        return ans;
    }
```

#### Analysis

- **Time Complexity**:Â O(nlogn)
- **Space Complexity**:Â O(1)

### Fast Slow Pointers

This problem is as same asÂ [142. Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/), you can refer to thisÂ [solution](https://leetcode.com/problems/linked-list-cycle-ii/discuss/1701055/JavaC%2B%2BPython-best-explanation-ever-happen's-for-this-problem)Â for the explanation of the slow fast pointer approach to solve this problem.

The key is to understand how to treatÂ **the input array as a linked list**.

Take the array [1,3,4,2]Â as an example, the index of this array is [0,1,2,3], we can map the index to theÂ nums[n].

0â†’1â†’3â†’2â†’4â†’3â†’2

Start fromÂ nums[n]Â as a new index, and so on, until the index exceeds the bounds. This produces a sequence similar to a linked list.

0â†’1â†’3â†’2â†’4â†’null

If there are a repeated numbers in the array, take the array [1,3,4,2,2]Â as an example,

0â†’1â†’3â†’2â†’4â†’3â†’2â†’4â†’2

Similarly, a linked list is like that:

0â†’1â†’3â†’2â†’4â†’2â†’4â†’2â†’â€¦ 

HereÂ 2â†’42 \to 42â†’4Â is a cycle, then this linked list can be abstracted as the following figure:

![Link List](https://assets.leetcode.com/users/images/aeb3e536-9615-466c-a2de-88a9a59ef255_1648626512.666411.png)

With extraÂ O(n)Â space, without modifying the input.

```java
    public int findDuplicate_fastSlow(int[] nums) {
        int slow = 0;
        int fast = 0;
        do {
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while (slow != fast);

        slow = 0;
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }
        
        return slow;
    }
```

#### Analysis

- **Time Complexity**:Â O(n)
- **Space Complexity**:Â O(1)

---

All suggestions are welcome.  
If you have any query or suggestion please comment below.  
Please upvoteğŸ‘ if you likeğŸ’— it. Thank you:-)

Explore MoreÂ [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). ğŸ˜‰ğŸ˜ƒğŸ’—