
Given stringsÂ `s1`,Â `s2`, andÂ `s3`, find whetherÂ `s3`Â is formed by anÂ **interleaving**Â ofÂ `s1`Â andÂ `s2`.

AnÂ **interleaving**Â of two stringsÂ `s`Â andÂ `t`Â is a configuration whereÂ `s`Â andÂ `t`Â are divided intoÂ `n`Â andÂ `m`Â 

substrings

Â respectively, such that:

- `s = s1 + s2 + ... + sn`
- `t = t1 + t2 + ... + tm`
- `|n - m| <= 1`
- TheÂ **interleaving**Â isÂ `s1 + t1 + s2 + t2 + s3 + t3 + ...`Â orÂ `t1 + s1 + t2 + s2 + t3 + s3 + ...`

**Note:**Â `a + b`Â is the concatenation of stringsÂ `a`Â andÂ `b`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg)

**Input:** s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
**Output:** true
**Explanation:** One way to obtain s3 is:
Split s1 into s1 = "aa" + "bc" + "c", and s2 into s2 = "dbbc" + "a".
Interleaving the two splits, we get "aa" + "dbbc" + "bc" + "a" + "c" = "aadbbcbcac".
Since s3 can be obtained by interleaving s1 and s2, we return true.

**Example 2:**

**Input:** s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc"
**Output:** false
**Explanation:** Notice how it is impossible to interleave s2 with any other string to obtain s3.

**Example 3:**

**Input:** s1 = "", s2 = "", s3 = ""
**Output:** true

**Constraints:**

- `0 <= s1.length, s2.length <= 100`
- `0 <= s3.length <= 200`
- `s1`,Â `s2`, andÂ `s3`Â consist of lowercase English letters.

**Follow up:**Â Could you solve it using onlyÂ `O(s2.length)`Â additional memory space?

## Solution

### Interview Guide: "Interleaving String" Problem

### Problem Understanding

In the "Interleaving String" problem, you are given three strings:Â `s1`,Â `s2`, andÂ `s3`. Your task is to determine whetherÂ `s3`Â can be formed by interleavingÂ `s1`Â andÂ `s2`. For example, ifÂ `s1 = "aabcc"`Â andÂ `s2 = "dbbca"`, thenÂ `s3 = "aadbbcbcac"`Â should returnÂ `true`, butÂ `s3 = "aadbbbaccc"`Â should returnÂ `false`.

### Key Points to Consider

#### 1. Understand the Constraints

Before diving into the solution, make sure you understand the problem's constraints. The lengths of the strings will not be more than 100 forÂ `s1`Â andÂ `s2`, and not more than 200 forÂ `s3`. This can help you gauge the time complexity you should aim for.

#### 2. Multiple Approaches

There are multiple ways to solve this problem, including:

- 2D Dynamic Programming
- 1D Dynamic Programming
- Recursion with Memoization

Each method has its own time and space complexity, so choose based on the problem's constraints.

#### 3. Space Optimization

While 2D Dynamic Programming is the most intuitive approach, you can reduce the space complexity to (O(\min(m, n))) by employing 1D Dynamic Programming. In an interview setting, discussing this optimization can impress your interviewer.

#### 4. Early Exit

If the sum of the lengths ofÂ `s1`Â andÂ `s2`Â does not match the length ofÂ `s3`, you can immediately returnÂ `false`. This can save computation time and demonstrate that you're mindful of edge cases.

#### 5. Explain Your Thought Process

Always explain your thought process and why you chose a particular approach. Discuss the trade-offs you're making in terms of time and space complexity.

#### Conclusion

The "Interleaving String" problem is an excellent example of a problem that can be tackled through Dynamic Programming or Recursion. Knowing the trade-offs between different approaches and optimizing for space can give you an edge in interviews. By taking the time to understand the problem, choosing the appropriate data structures, and optimizing your approach, you'll not only solve the problem but also demonstrate a well-rounded skill set.

---

### Live Coding & Explenation: 1D Dynamic Programming

[](https://youtu.be/iv_cTwwsRxs)

---

### Approach: 2D Dynamic Programming

To solve the "Interleaving String" problem using 2D Dynamic Programming, we utilize a 2D arrayÂ `dp[i][j]`Â to represent whether the substringÂ `s3[:i+j]`Â can be formed by interleavingÂ `s1[:i]`Â andÂ `s2[:j]`.

### Key Data Structures:

- **dp**: A 2D list to store the results of subproblems.

### Enhanced Breakdown:

1. **Initialization**:
    
    - Calculate lengths ofÂ `s1`,Â `s2`, andÂ `s3`.
    - If the sum of lengths ofÂ `s1`Â andÂ `s2`Â is not equal to the length ofÂ `s3`, return false.
    - Initialize theÂ `dp`Â array with dimensionsÂ `(m+1) x (n+1)`, settingÂ `dp[0][0] = True`.
2. **Base Cases**:
    
    - Fill in the first row ofÂ `dp`Â array, considering only the characters fromÂ `s1`.
    - Fill in the first column ofÂ `dp`Â array, considering only the characters fromÂ `s2`.
3. **DP Loop**:
    
    - Loop through each possibleÂ `(i, j)`Â combination, starting fromÂ `(1, 1)`.
    - UpdateÂ `dp[i][j]`Â based on the transitionÂ `dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i+j-1]) or (dp[i][j-1] and s2[j-1] == s3[i+j-1])`.
4. **Wrap-up**:
    
    - Return the value stored inÂ `dp[m][n]`, which indicates whetherÂ `s3`Â can be formed by interleavingÂ `s1`Â andÂ `s2`.

### Complexity:

**Time Complexity:**

- The solution iterates over each possibleÂ (i,j)(i, j)(i,j)Â combination, leading to a time complexity ofÂ O(mÃ—n)O(m \times n)O(mÃ—n).

**Space Complexity:**

- The space complexity isÂ O(mÃ—n)O(m \times n)O(mÃ—n)Â due to the 2DÂ dpdpdpÂ array.

---

### Approach: 1D Dynamic Programming

The optimization from 2D to 1D DP is based on the observation that the state ofÂ `dp[i][j]`Â in the 2D DP array depends only onÂ `dp[i-1][j]`Â andÂ `dp[i][j-1]`. Therefore, while iterating through the strings, the current state only depends on the states in the previous row of the 2D DP array, which means we can optimize our space complexity by just keeping track of one row (1D DP).

#### Key Data Structures:

- **dp**: A 1D list that stores whether the substringÂ `s3[:i+j]`Â can be formed by interleavingÂ `s1[:i]`Â andÂ `s2[:j]`. Initially, all values are set toÂ `False`Â exceptÂ `dp[0]`, which is set toÂ `True`.

#### Enhanced Breakdown:

1. **Initialization**:
    
    - First, calculate the lengths ofÂ `s1`,Â `s2`, andÂ `s3`.
    - Check if the sum of the lengths ofÂ `s1`Â andÂ `s2`Â equals the length ofÂ `s3`. If it doesn't, returnÂ `False`Â asÂ `s3`Â cannot be formed by interleavingÂ `s1`Â andÂ `s2`.
2. **Optimization Check**:
    
    - IfÂ `m < n`, swapÂ `s1`Â andÂ `s2`. This is to ensure thatÂ `s1`Â is not longer thanÂ `s2`, which helps in optimizing the space complexity toÂ `O(min(m, n))`.
3. **Base Cases**:
    
    - Initialize a 1D arrayÂ `dp`Â of lengthÂ `n+1`Â withÂ `False`.
    - SetÂ `dp[0] = True`Â because an emptyÂ `s1`Â andÂ `s2`Â can interleave to form an emptyÂ `s3`.
4. **Single-Row DP Transition**:
    
    - Iterate throughÂ `s1`Â andÂ `s2`Â to update theÂ `dp`Â array.
    - For each character inÂ `s1`, iterate throughÂ `s2`Â and update theÂ `dp`Â array based on the transition rule:Â `dp[j] = (dp[j] and s1[i] == s3[i+j]) or (dp[j-1] and s2[j] == s3[i+j])`.
    - The transition rule checks if the currentÂ `s3[i+j]`Â can be matched by eitherÂ `s1[i]`Â orÂ `s2[j]`, relying solely on the previous values in theÂ `dp`Â array.
5. **Wrap-up**:
    
    - The final value in theÂ `dp`Â array will indicate whether the entireÂ `s3`Â can be formed by interleavingÂ `s1`Â andÂ `s2`.
    - ReturnÂ `dp[n]`.

#### Complexity:

The primary advantage of this 1D DP approach is its space efficiency. While it maintains the same time complexity as the 2D DP approachÂ O(mÃ—n)O(m \times n)O(mÃ—n), the space complexity is optimized toÂ O(minâ¡(m,n))O(\min(m, n))O(min(m,n)).

**Time Complexity:**

- The solution iterates over each character ofÂ `s1`Â andÂ `s2`Â once, leading to a complexity ofÂ O(mÃ—n)O(m \times n)O(mÃ—n).

**Space Complexity:**

- The space complexity is optimized toÂ O(minâ¡(m,n))O(\min(m,n))O(min(m,n))Â as we're only using a single 1D array instead of a 2D matrix.

---

### Approach: Recursion with Memoization

In this approach, we recursively check whether the substringÂ `s3[k:]`Â can be formed by interleavingÂ `s1[i:]`Â andÂ `s2[j:]`. We store the results of these sub-problems in a dictionary namedÂ `memo`.

#### Key Data Structures:

- **memo**: A dictionary to store the results of subproblems.

#### Enhanced Breakdown:

1. **Initialization**:
    
    - Calculate lengths ofÂ `s1`,Â `s2`, andÂ `s3`.
    - If the sum of lengths ofÂ `s1`Â andÂ `s2`Â is not equal to the length ofÂ `s3`, return false.
2. **Recursive Function**:
    
    - Define a recursive functionÂ `helper`Â which takes indicesÂ `i`,Â `j`, andÂ `k`Â as inputs.
    - The function checks whether the substringÂ `s3[k:]`Â can be formed by interleavingÂ `s1[i:]`Â andÂ `s2[j:]`.
    - Store the result of each subproblem in theÂ `memo`Â dictionary.
3. **Wrap-up**:
    
    - Return the result of the recursive function for the initial valuesÂ `i=0, j=0, k=0`.

#### Complexity:

**Time Complexity:**

- Each combination of (i, j) is computed once and stored in the memo, leading to a time complexity ofÂ O(mÃ—n)O(m \times n)O(mÃ—n).

**Space Complexity:**

- The space complexity isÂ O(mÃ—n)O(m \times n)O(mÃ—n)Â for storing the memoization results.

---

### Performance

|Language|Runtime (ms)|Memory (MB)|
|---|---|---|
|Rust|0|2.1|
|C++|0|6.4|
|Go|1|1.9|
|Java|3|40.5|
|Python3 (1D DP)|31|16.4|
|Python3 (2D DP)|34|16.5|
|Python3 (Recursion)|45|17.4|
|C#|54|38.4|
|JavaScript|61|43.1|

![ir.png](https://assets.leetcode.com/users/images/6a85642f-8740-4891-a310-591b172bcee8_1692924054.2926686.png)

### Code 1D Dynamic Programming



```java
public class Solution {
    public boolean isInterleave(String s1, String s2, String s3) {
        int m = s1.length(), n = s2.length(), l = s3.length();
        if (m + n != l) return false;

        boolean[] dp = new boolean[n + 1];
        dp[0] = true;

        for (int j = 1; j <= n; ++j) {
            dp[j] = dp[j - 1] && s2.charAt(j - 1) == s3.charAt(j - 1);
        }

        for (int i = 1; i <= m; ++i) {
            dp[0] = dp[0] && s1.charAt(i - 1) == s3.charAt(i - 1);
            for (int j = 1; j <= n; ++j) {
                dp[j] = (dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) || (dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));
            }
        }
        
        return dp[n];
    }
}
```

### Code 2D Dynamic Programming

Python

```python
class Solution:
    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:
        m, n, l = len(s1), len(s2), len(s3)
        if m + n != l:
            return False
        
        dp = [[False] * (n + 1) for _ in range(m + 1)]
        dp[0][0] = True
        
        for i in range(1, m + 1):
            dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1]
        
        for j in range(1, n + 1):
            dp[0][j] = dp[0][j-1] and s2[j-1] == s3[j-1]
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i+j-1]) or (dp[i][j-1] and s2[j-1] == s3[i+j-1])
        
        return dp[m][n]
```

### Code Recursion with Memoization

Python

```python
class Solution:
    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:
        m, n, l = len(s1), len(s2), len(s3)
        if m + n != l:
            return False
        
        memo = {} 
        
        def helper(i: int, j: int, k: int) -> bool:
            if k == l:
                return True
            
            if (i, j) in memo:
                return memo[(i, j)]
            
            ans = False
            if i < m and s1[i] == s3[k]:
                ans = ans or helper(i + 1, j, k + 1)
                
            if j < n and s2[j] == s3[k]:
                ans = ans or helper(i, j + 1, k + 1)
            
            memo[(i, j)] = ans
            return ans
        
        return helper(0, 0, 0)
```

Both the given approaches provide efficient ways to solve the problem, with the first approach focusing on optimizing space and the second leveraging the power of memoization to save time. Choosing between them depends on the specific constraints and requirements of the application. ğŸ’¡ğŸŒ ğŸ‘©â€ğŸ’»ğŸ‘¨â€ğŸ’»